<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  

  <title>ELBE</title>
  <generator uri="https://github.com/jekyll/jekyll">Jekyll v2.5.3</generator>
    <icon>https://elbe-rfs.org/apple-touch-icon-precomposed.png</icon>
  <subtitle>ELBE is a Debian based system to generate root-filesystems for embedded devices.</subtitle>
  <link href="https://elbe-rfs.org/atom.xml" rel="self"/>
  <link href="https://elbe-rfs.org/" rel="alternate" type="text/html"/>
  <updated>2021-06-16T15:11:49+02:00</updated>
  <id>https://elbe-rfs.org/</id>
  <author>
    <name></name>
    <uri>https://elbe-rfs.org/</uri>
    
  </author>

  
  <entry>
    <title>ELBE 3 release</title>
    <link href="https://elbe-rfs.org/news/v300/"/>
    <updated>2019-03-14T00:00:00+01:00</updated>
    <id>https://elbe-rfs.org/news/v300</id>
    <author>
      <name></name>
      <uri>https://elbe-rfs.org/</uri>
      
    </author>
    <content type="html">
      
      &lt;p&gt;All features of elbe-2.x and elbe-2.9.x are still available.
The XML format is compatible.&lt;/p&gt;

&lt;p&gt;Debian packages for “ELBE 3” are available from linutronix.
Add sth. like this to your sources.list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http://debian.linutronix.de/elbe stretch main
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;new-development-model&quot;&gt;New development model&lt;/h2&gt;
&lt;p&gt;Future development will be integrated into the ‘master’ branch of
github. There will be no longer “testing” releases of ELBE. The
next stable release will be “ELBE 4” and includes just one new
feature or bugfix.&lt;/p&gt;

&lt;p&gt;The most important new features since ELBE 2.4 are described in the
following chapters.&lt;/p&gt;

&lt;h2 id=&quot;variant-management&quot;&gt;Variant management&lt;/h2&gt;
&lt;p&gt;Other build-systems allow building different flavours or variants of a
image based on some config values. This eases the maintainance of very
similar images.&lt;/p&gt;

&lt;p&gt;A new parameter ‘–variant’ was added to the ‘initvm’ and ‘preprocess’
subcommand. A XML tag inside the XML file given to ‘preprocess’ can contain a
‘variant’ attribute. If the value of the variant attribute inside XML matches
with a variant given as parameter to the preprocess command, the XML tag
stays inside the XML file. If the XML tag has a variant attribute but
doesn’t match with the variant given as parameter to ‘preprocess’ the
XML tag will be dropped. If no ‘variant’ parameter is given to the
‘preprocess’ subcommand all tags with a ‘variant’ parameter are dropped.&lt;/p&gt;

&lt;p&gt;This allows XML snippets like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;url variant=&#39;security&#39;&amp;gt;
        &amp;lt;binary&amp;gt;http://security.debian.org/ stretch/updates main&amp;lt;/binary&amp;gt;
        &amp;lt;source&amp;gt;http://security.debian.org/ stretch/updates main&amp;lt;/source&amp;gt;
&amp;lt;/url&amp;gt;
&amp;lt;pkg-list&amp;gt;
        &amp;lt;pkg variant=&#39;security&#39;&amp;gt;openssh-server&amp;lt;/pkg&amp;gt;
        &amp;lt;pkg variant=&#39;audio,video&#39;&amp;gt;totem&amp;lt;/pkg&amp;gt;
&amp;lt;/pkg-list&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is also possible to use multiple sections with variant attributes like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;pkg-list variant=&#39;audio&amp;gt;
        &amp;lt;pkg&amp;gt;alsa&amp;lt;/pkg&amp;gt;
        &amp;lt;pkg&amp;gt;pavucontrol&amp;lt;/pkg&amp;gt;
&amp;lt;/pkg-list&amp;gt;
&amp;lt;pkg-list variant=&#39;video&amp;gt;
        &amp;lt;pkg&amp;gt;totem&amp;lt;/pkg&amp;gt;
        &amp;lt;pkg&amp;gt;ffmpeg&amp;lt;/pkg&amp;gt;
&amp;lt;/pkg-list&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This needs defining mergeable sections by xpath.&lt;/p&gt;

&lt;p&gt;This is the list of currently supported mergeable sections:
  - target/finetuning
  - target/pkg-list
  - project/buildimage/pkg-list&lt;/p&gt;

&lt;p&gt;If one of these sections occure multiple times the contents are merged into a
single section.&lt;/p&gt;

&lt;p&gt;If the above example will be submited by specifying&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;elbe initvm submit --variant=audio,security&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will use all elements but not&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;pkg&amp;gt;totem&amp;lt;/pkg&amp;gt;
&amp;lt;pkg&amp;gt;ffmpeg&amp;lt;/pkg&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;archivedir&quot;&gt;archivedir&lt;/h2&gt;
&lt;p&gt;The new XML element ‘archivedir’ points to an local directory and adds
the content into a newly created archive. ‘archivedir’ can be
specified more then once. The content of the direcories is copied
in order of appearance. Existing files are overwritten by the later
ones. ‘archive’ and ‘archivedir’ are mutual exclusive.&lt;/p&gt;

&lt;p&gt;‘archivedir’ is only allowed in XML files going into ‘elbe preprocess’ or
‘elbe initvm’ and are converted into an ‘archive’ tag by this elbe subcommands.&lt;/p&gt;

&lt;p&gt;Example snippet to use ‘archivedir’:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;archivedir&amp;gt;foo&amp;lt;/archivedir&amp;gt;
&amp;lt;archivedir variant=&quot;production&quot;&amp;gt;bar&amp;lt;/archivedir&amp;gt;
&amp;lt;archivedir keep-attributes=&quot;true&quot;&amp;gt;baz&amp;lt;/archivedir&amp;gt;
&amp;lt;archivedir&amp;gt;file:///overlay&amp;lt;/archivedir&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;sdk&quot;&gt;SDK&lt;/h2&gt;
&lt;p&gt;Currently only x86_64 host and armhf targets are supported.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ elbe initvm submit --keep-files --writeproject uuid.prj examples/armhf-ti-beaglebone-black.xml
$ elbe control build_sdk `cat uuid.prj`
$ elbe control wait_busy `cat uuid.prj`
$ mkdir -p sdk
$ elbe control --output sdk get_files `cat uuid.prj`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use the SDK, follow the instructions from the
&lt;a href=&quot;https://www.yoctoproject.org/docs/2.1/sdk-manual/sdk-manual.html#sdk-using-the-standard-sdk&quot;&gt;Yocto SDK Manual (Chapter 2)&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;docker&quot;&gt;Docker&lt;/h2&gt;
&lt;p&gt;It’s possible to run elbe inside a docker environment. ‘contrib/dockerfile’
inside the elbe source includes a Makefile for generating a Dockerfile and
running/stopping the container.&lt;/p&gt;

&lt;h2 id=&quot;debootstrap-specify-variant-add-extra-packages&quot;&gt;debootstrap: specify variant, add extra packages&lt;/h2&gt;
&lt;p&gt;ELBE 3 allows more specific control over debootstrapping the base system.&lt;/p&gt;

&lt;p&gt;debootstrap variants are used to define, what is going to be
installed in a basic debian system. Known variants are:
 * minbase, which only includes essential packages and apt
 * buildd, which installs the build-essential packages into the rfs
 * fakechroot, which installs the packages without root privileges&lt;/p&gt;

&lt;p&gt;E.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;debootstrapvariant&amp;gt;minbase&amp;lt;/debootstrapvariant&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;can now be used in an ELBE XML to specify the debootstrapvariant.&lt;/p&gt;

&lt;p&gt;The debootstrapvariant element also allows an “includepkgs” attribute
to specify additional packages that should be installed during debootstrap.&lt;/p&gt;

&lt;h2 id=&quot;project-finetuning&quot;&gt;Project finetuning&lt;/h2&gt;
&lt;p&gt;Is a new finetung list that is executed after the images are created.
It supports converting an image into a different format, copy files from
or to a partition or setting a specific packer for an image. E.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;project-finetuning&amp;gt;
  &amp;lt;losetup img=&quot;sdcard.img&quot;&amp;gt;
    &amp;lt;!-- globs work, but must make sure, that only a single file is matched --&amp;gt;
    &amp;lt;copy_from_partition part=&quot;1&quot; artifact=&quot;vmlinuz&quot;&amp;gt;/vmlinuz-3.16.0-*-arm64&amp;lt;/copy_from_partition&amp;gt;
  &amp;lt;/losetup&amp;gt;
  &amp;lt;img_convert fmt=&quot;qcow2&quot; dst=&quot;sdcard.qcow2&quot;&amp;gt;sdcard.img&amp;lt;/img_convert&amp;gt;
  &amp;lt;set_packer packer=&quot;tarxz&quot;&amp;gt;sdcard.qcow2&amp;lt;/set_packer&amp;gt;
&amp;lt;/project-finetuning&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;pbuilder-build-profiles&quot;&gt;pbuilder: build-profiles&lt;/h2&gt;
&lt;p&gt;dpkg-buildpackage allows to specify build profiles using -P option&lt;/p&gt;

&lt;p&gt;Specifying a profile is now also supported by elbe by adding –profile to the
“elbe pbuilder” command.&lt;/p&gt;

&lt;h2 id=&quot;grubx86-support-for-uefi-incl-hybrid-boot&quot;&gt;grub/x86: support for UEFI incl. hybrid boot&lt;/h2&gt;
&lt;p&gt;It’s now possible to build x86 images with UEFI grub support. See
examples/x86_64-pc-hdimg-grub-hybrid-stretch.xml and
examples/x86_64-pc-hdimg-grub-uefi-stretch.xml for usage.&lt;/p&gt;

&lt;h2 id=&quot;elbe-debianize-supports-debianizing-u-boot&quot;&gt;elbe-debianize: supports debianizing u-boot&lt;/h2&gt;
&lt;p&gt;debianizing u-boot &amp;gt;= 2014.04 is now supported by “elbe debianize”&lt;/p&gt;

&lt;h2 id=&quot;initvm-is-registered-at-libvirt&quot;&gt;Initvm is registered at libvirt&lt;/h2&gt;
&lt;p&gt;ELBE 2.x used a tmux session to run the initvm in the background. In ELBE 3
this was replaced by registering the initvm at libvirtd. “elbe initvm” now
uses the python libvirt bindings to control the initvm. There is still a
Makefile next to the initvm image to start/stop the initvm without using
libvirt.&lt;/p&gt;

&lt;h2 id=&quot;upgradedowngrade-version-of-elbe-inside-the-initvm&quot;&gt;Upgrade/downgrade version of elbe inside the initvm&lt;/h2&gt;
&lt;p&gt;‘elbe control install_elbe_version [version]’ makes the initvm install a
specific elbe version. It defaults to the version of the elbe executable used
to issue the command.&lt;/p&gt;

&lt;h2 id=&quot;source-code-cleanups&quot;&gt;Source-code cleanups&lt;/h2&gt;
&lt;p&gt;Elbe now uses SPDX licence tags.
It follows the pep8 codingy-style.
And a lot of pylint complains have been fixed.&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>elbe v2.0 released</title>
    <link href="https://elbe-rfs.org/news/v200/"/>
    <updated>2017-08-09T00:00:00+02:00</updated>
    <id>https://elbe-rfs.org/news/v200</id>
    <author>
      <name></name>
      <uri>https://elbe-rfs.org/</uri>
      
    </author>
    <content type="html">
      
      &lt;p&gt;All features of elbe-1.x are still available. The XML format is compatible.
Additional the following features are added:&lt;/p&gt;

&lt;p&gt;The following new features can be used for targets:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;stretch target support&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;arm64/aarch64 support&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;extended partitions support for msdoshd&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;support xmls with xincludes, see e.g.
  &lt;a href=&quot;https://github.com/Linutronix/elbe/blob/devel/elbe-2.0/examples/x86_32-pc-hdimg-with-include-development.xml&quot;&gt;examples/x86_32-pc-hdimg-with-include-development.xml&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;comments are now longer removed from elbe xml files, if e.g. chg_archive is called&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The pbuilder is able to build binary debian packages from debian source packages
for a certain project and host them in a debian repo:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;more information about the pbuilder support are in the man-page
  &lt;a href=&quot;https://elbe-rfs.org/docs/sphinx/elbe-pbuilder.html&quot;&gt;elbe-pbuilder.1&lt;/a&gt;.
  There is also an example
  &lt;a href=&quot;https://github.com/Linutronix/elbe/blob/devel/elbe-2.0/examples/armhf-ti-beaglebone-black.xml&quot;&gt;examples/armhf-ti-beaglebone-black.xml&lt;/a&gt;
  that shows howto trigger pbuilder jobs during image generation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;the packages build by pbuilder are hosted in a project local debian repo.
There are elbe commands to e.g. copy the repo to the host pc. The commands
are explained in the
  &lt;a href=&quot;https://elbe-rfs.org/docs/sphinx/elbe-prjrepo.html&quot;&gt;elbe-prjrepo.1&lt;/a&gt;
man page.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;elbe debianize&lt;/em&gt; helps generating debian source packages for common source
trees like the linux kernel:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;elbe debianize currently supports packaging the linux kernel and the barebox
bootloader. More infos can be found in the man page
 &lt;a href=&quot;https://elbe-rfs.org/docs/sphinx/elbe-debianize.html&quot;&gt;elbe-debianize.1&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Other user visible changes are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;the progress of an image or pbuilder run is now displayed on the host pc&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;it is posible to blacklist packages that they are not added to the sysroot.
More infos about this feature are in the commit message of the according
 &lt;a href=&quot;https://github.com/Linutronix/elbe/commit/0d40931e2bd3c2f0e129749aa16c5ef17b0fa968&quot;&gt;git commit&lt;/a&gt;
The
 &lt;a href=&quot;https://elbe-rfs.org/docs/sphinx/devel_elbe-2.0/article-elbe-schema-reference.html#type-blacklist&quot;&gt;XML schema reference&lt;/a&gt;
describes the syntax.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;we now generate &lt;a href=&quot;https://elbe-rfs.org/docs/sphinx/index.html&quot;&gt;docs&lt;/a&gt; for multiple versions of elbe&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;there are systemd service files for all elbe daemons&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Debian packages for elbe 2.x are available from linutronix.
Add sth. like this to your sources.list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http://debian.linutronix.de/elbe stretch main
deb-src http://debian.linutronix.de/elbe stretch main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new development branch on github is devel/elbe-3.0.
To retrieve Debian packages for the development version of elbe
add sth. like this to your sources.list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http://debian.linutronix.de/elbe-testing stretch main
deb-src http://debian.linutronix.de/elbe-testing stretch main
&lt;/code&gt;&lt;/pre&gt;

    </content>
  </entry>
  
  <entry>
    <title>elbe v1.0 released</title>
    <link href="https://elbe-rfs.org/news/v100/"/>
    <updated>2015-12-24T00:00:00+01:00</updated>
    <id>https://elbe-rfs.org/news/v100</id>
    <author>
      <name></name>
      <uri>https://elbe-rfs.org/</uri>
      
    </author>
    <content type="html">
      
      &lt;p&gt;There are no big changes since last devel release elbe version 0.9.8&lt;/p&gt;

&lt;p&gt;The Debian packages for elbe 1.x are available from linutronix,
add sth. like this to your sources.list&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http://debian.linutronix.de/elbe jessie main
deb-src http://debian.linutronix.de/elbe jessie main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;New elbe 1.x releases are published in the master branch.&lt;/p&gt;

&lt;p&gt;The new development branch on github is devel/elbe-2.0
To retrieve Debian packages for the development version of elbe
add sth. like this to your sources.list&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http://debian.linutronix.de/elbe-testing jessie main
deb-src http://debian.linutronix.de/elbe-testing jessie main
&lt;/code&gt;&lt;/pre&gt;

    </content>
  </entry>
  
  <entry>
    <title>elbe v0.9.8 released</title>
    <link href="https://elbe-rfs.org/news/v098/"/>
    <updated>2015-12-14T00:00:00+01:00</updated>
    <id>https://elbe-rfs.org/news/v098</id>
    <author>
      <name></name>
      <uri>https://elbe-rfs.org/</uri>
      
    </author>
    <content type="html">
      
      &lt;p&gt;The ‘big’ news in this release include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;an USB Monitor for updated&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;elbe chg_archive takes a directory OR a .tar.gz file as input&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pbuilder support to rebuild debian packages&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Howto use the pbuilder feature:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# build an initvm with the current elbe version 0.9.8
$ elbe initvm create
# retrieve the source of a debian package you&#39;d like to rebuild
$ apt-get source nano
# go to the source directory
$ cd nano-2.4.2
# we currently only support debian source format git and native
$ echo &quot;3.0 (native)&quot; &amp;gt; debian/source/format
# if wanted, the source or debian/ files can be modified now
$ vi src/nano.c
# increase the package version
$ dch
# use any ELBE XML file to..
$ zcat /usr/share/doc/elbe-doc/examples/armhf-ti-beaglebone-black.xml.gz &amp;gt; /tmp/bbb.xml
# ..rebuild the package against
$ elbe pbuilder build --xmlfile /tmp/bbb.xml
&lt;/code&gt;&lt;/pre&gt;

    </content>
  </entry>
  
  <entry>
    <title>ELBE technical Details</title>
    <link href="https://elbe-rfs.org/internals/"/>
    <updated>2015-12-14T00:00:00+01:00</updated>
    <id>https://elbe-rfs.org/internals</id>
    <author>
      <name></name>
      <uri>https://elbe-rfs.org/</uri>
      
    </author>
    <content type="html">
      
      &lt;p&gt;This article describes the qemu features ELBE is using.&lt;/p&gt;

&lt;p&gt;One essential point to understand is that qemu combines two
fundamentally different functionalities, which can also be used
independently and that ELBE uses both of them separately:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Virtualization (running a machine-in-a-machine)&lt;/li&gt;
  &lt;li&gt;Emulation (running foreign machine-code)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Both are traditionally used in combination (to run, for example, a full
ARM-based Android mobile device on an x86-based development machine).
ELBE, however, uses both functionalities separately, each one without
the other:&lt;/p&gt;

&lt;p&gt;At the outside, ‘elbe initvm’ runs a full virtual machine with the host
system’s architecture, using the kvm technology. On a typical x86-based
host, this VM still runs x86 code at full efficiency, but does so in a
fully encapsulated environment, running its own kernel with virtualized
devices in it own root-file resides in a single file (buildenv.img) on
the hosts file system. This virtual machine must be booted before it can
be used and communication happens through its virtual console or through
virtual network connections.&lt;/p&gt;

&lt;p&gt;At the inside, ‘elbe chroot’ runs a CPU emulation environment without
machine virtualization. This command actually does two separate things
at once:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;chroot - i.e. divert all child processes to view a certain directory
as their root. Within this directory, there is a full set of
subdirectories (/etc, /usr, /var, …) and the child processes cannot
see or access anything outside this directory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;qemu-user-binfmt - i.e. register qemu in such a way that binaries of
the target architecture (e.g. ARM) are transparently called via qemu
(this fairly complex technique is documented e.g. on
https://wiki.debian.org/QemuUserEmulation)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The effect is that inside this ‘elbe chroot’ environment target .deb
packages can be deployed and target binaries executed. However, there is
not kernel running in the target architecture and the devices are still
those provided by the encapsulating initvm virtual machine.&lt;/p&gt;

&lt;p&gt;While at the ‘elbe initvm’ boundary, the outside can only see a single
‘qemu’ process and a single ‘buildenv.img’ file, the ‘elbe chroot’
boundary is much more transparent, allowing the outside to observe
individual processes and files of the inner environment.&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>ELBE in a nutshell</title>
    <link href="https://elbe-rfs.org/whatiselbe/"/>
    <updated>2015-11-16T00:00:00+01:00</updated>
    <id>https://elbe-rfs.org/whatiselbe</id>
    <author>
      <name></name>
      <uri>https://elbe-rfs.org/</uri>
      
    </author>
    <content type="html">
      
      &lt;p&gt;This article describes why the ELBE project was born.&lt;/p&gt;

&lt;h1 id=&quot;early-embedded-linux-devices&quot;&gt;early embedded Linux devices&lt;/h1&gt;
&lt;p&gt;Well, first we should look at embedded devices to see what they used to look
like and how some of them look like today.&lt;/p&gt;

&lt;p&gt;The first devices, that were initially called embedded Linux, had about 4MiB
flash and around 16MiB of RAM. With these constrains in mind people started to
hack a root file system for their devices. If they had bad luck you had to
start with building a cross toolchain first.&lt;/p&gt;

&lt;p&gt;Once that part was over you could focus on the user land. Busybox is a good
tool to start with since it contains most of the required programs in a small
single binary. Those programs and a few configurations files on top and you
were done. Maybe you had to compile your “added value” binary or something
else that was not part of busybox but that was it.&lt;/p&gt;

&lt;h1 id=&quot;cross-build-toolkits&quot;&gt;Cross-build Toolkits&lt;/h1&gt;
&lt;p&gt;Now sum up the single steps which were required to create a root file from
scratch and create a tool to ease your life. This is when tools like
OpenEmbedded, EDLK were born. Those tools are still good as long as they are
well maintained. They aren’t just projects that are that small these days.
A lot of them are getting very complex. This includes hardware that has much
more RAM and a GiBs of NAND flash if not replaced by a disk or mmc card and
the software, that is used, is more extensive.&lt;/p&gt;

&lt;h1 id=&quot;rootfilesystems-are-getting-bigger-and-bigger&quot;&gt;Rootfilesystems are getting bigger and bigger&lt;/h1&gt;
&lt;p&gt;A lot of libraries are used to ease the development of a system.
A toolkit for GUI development, several libraries for multimedia support just
to name a few.&lt;/p&gt;

&lt;p&gt;Depending on the build environment that is used, it is more or less difficult
to add a package that is not yet included. It depends on the scripting
language that is used, the format keeping the build instructions and the
user’s ability to understand it and make changes.&lt;/p&gt;

&lt;h1 id=&quot;adding-debuging-tools-is-not-that-easy&quot;&gt;Adding Debuging Tools is not that easy&lt;/h1&gt;
&lt;p&gt;Adding a debug version of a package to the root file system means a rebuild or
restart of the build process to create this piece of the rootfile system
assuming that a debug version can be selected (and not added to the build
process). Even then the debug version isn’t installed in a jiffy.&lt;/p&gt;

&lt;p&gt;There is usually one person in charge of the root file system and a few others
that are developing the application or a component of the application. One of
the application developers has a problem and wants just to install a debug
version of the library in question or replace it with a later version of it or
a substitute library just to see if his problem goes away or not.
He doesn’t necessarily know how to handle the build environment to make such
changes. So he has to ask the person in charge of the root filesystem to make
this change and send him the new filesystem.&lt;/p&gt;

&lt;p&gt;The application developer never did this kind of work because the Linux
distribution on his desktop computer takes care of these things for him.
The same distribution runs a test suite (if available) of the package after it
has been built to spot problems in the compiled binaries which can’t be run if
the package is cross compiled.&lt;/p&gt;

&lt;h1 id=&quot;no-bugtracking-informations-available&quot;&gt;No Bugtracking Informations available&lt;/h1&gt;
&lt;p&gt;Another missing feature is the bug tracking against all packages in the root
file system including security updates. This can be a full time job for one
person even just by looking after 10 packages with a reasonable size. So why
try to do a lot of work alone while this work is already done by large
communities around Linux distribution like Debian?&lt;/p&gt;

&lt;h1 id=&quot;debian-for-embedded&quot;&gt;Debian for embedded?&lt;/h1&gt;
&lt;p&gt;Instead of doing the work again we tried to figure out how Debian could be
reused in a way that will fulfill our needs.&lt;/p&gt;

&lt;p&gt;Continue reading &lt;a href=&quot;https://elbe-rfs.org/docs/elbeoverview-en.html&quot;&gt;ELBE Overview&lt;/a&gt;.&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>Secure</title>
    <link href="https://elbe-rfs.org/feature/secure/"/>
    <updated>2015-11-16T00:00:00+01:00</updated>
    <id>https://elbe-rfs.org/feature/secure</id>
    <author>
      <name></name>
      <uri>https://elbe-rfs.org/</uri>
      
    </author>
    <content type="html">
      
      &lt;p&gt;ELBE reuses the security of Debian. An update-checker informs if security
updates are available.&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>Reproducable Images</title>
    <link href="https://elbe-rfs.org/feature/reproducable/"/>
    <updated>2015-11-16T00:00:00+01:00</updated>
    <id>https://elbe-rfs.org/feature/reproducable</id>
    <author>
      <name></name>
      <uri>https://elbe-rfs.org/</uri>
      
    </author>
    <content type="html">
      
      &lt;p&gt;The Rootfilesystem is described in a single XML file.&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>Based on Debian</title>
    <link href="https://elbe-rfs.org/feature/debianbased/"/>
    <updated>2015-11-16T00:00:00+01:00</updated>
    <id>https://elbe-rfs.org/feature/debianbased</id>
    <author>
      <name></name>
      <uri>https://elbe-rfs.org/</uri>
      
    </author>
    <content type="html">
      
      &lt;p&gt;No need to build all binaries. ELBE reuses Debian packages!&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>ELBE ADK</title>
    <link href="https://elbe-rfs.org/feature/adk/"/>
    <updated>2015-11-16T00:00:00+01:00</updated>
    <id>https://elbe-rfs.org/feature/adk</id>
    <author>
      <name></name>
      <uri>https://elbe-rfs.org/</uri>
      
    </author>
    <content type="html">
      
      &lt;p&gt;a native Application Development Kit is included&lt;/p&gt;

    </content>
  </entry>
  
  <entry>
    <title>elbe v0.9.7 released</title>
    <link href="https://elbe-rfs.org/news/v097/"/>
    <updated>2015-10-16T00:00:00+02:00</updated>
    <id>https://elbe-rfs.org/news/v097</id>
    <author>
      <name></name>
      <uri>https://elbe-rfs.org/</uri>
      
    </author>
    <content type="html">
      
      &lt;p&gt;a major speedup of ‘elbe initvm submit’ was realized, because image files
are gzipped now inside the initvm. This reduces the copy time to the host PC
by far.&lt;/p&gt;

    </content>
  </entry>
  
  
</feed>